// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: form_fields.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFormField = `-- name: CreateFormField :one
INSERT INTO form_fields (
    form_template_id, form_section_id, field_name,
    field_type_id, field_order, conditional_logic
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, form_template_id, form_section_id, field_name, field_type_id, field_order, conditional_logic, status, created_at, updated_at, deleted_at
`

type CreateFormFieldParams struct {
	FormTemplateID   pgtype.UUID `json:"form_template_id"`
	FormSectionID    pgtype.UUID `json:"form_section_id"`
	FieldName        string      `json:"field_name"`
	FieldTypeID      pgtype.UUID `json:"field_type_id"`
	FieldOrder       int32       `json:"field_order"`
	ConditionalLogic []byte      `json:"conditional_logic"`
}

func (q *Queries) CreateFormField(ctx context.Context, arg CreateFormFieldParams) (FormField, error) {
	row := q.db.QueryRow(ctx, createFormField,
		arg.FormTemplateID,
		arg.FormSectionID,
		arg.FieldName,
		arg.FieldTypeID,
		arg.FieldOrder,
		arg.ConditionalLogic,
	)
	var i FormField
	err := row.Scan(
		&i.ID,
		&i.FormTemplateID,
		&i.FormSectionID,
		&i.FieldName,
		&i.FieldTypeID,
		&i.FieldOrder,
		&i.ConditionalLogic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteFormField = `-- name: DeleteFormField :exec
UPDATE form_fields
SET 
    status = 'inactive',
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteFormField(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFormField, id)
	return err
}

const getFormFieldByID = `-- name: GetFormFieldByID :one
SELECT id, form_template_id, form_section_id, field_name, field_type_id, field_order, conditional_logic, status, created_at, updated_at, deleted_at FROM form_fields
WHERE id = $1 AND status = 'active' AND deleted_at IS NULL
`

func (q *Queries) GetFormFieldByID(ctx context.Context, id pgtype.UUID) (FormField, error) {
	row := q.db.QueryRow(ctx, getFormFieldByID, id)
	var i FormField
	err := row.Scan(
		&i.ID,
		&i.FormTemplateID,
		&i.FormSectionID,
		&i.FieldName,
		&i.FieldTypeID,
		&i.FieldOrder,
		&i.ConditionalLogic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFormFields = `-- name: GetFormFields :many
SELECT id, form_template_id, form_section_id, field_name, field_type_id, field_order, conditional_logic, status, created_at, updated_at, deleted_at FROM form_fields
WHERE form_template_id = $1 AND status = 'active' AND deleted_at IS NULL
ORDER BY field_order
`

func (q *Queries) GetFormFields(ctx context.Context, formTemplateID pgtype.UUID) ([]FormField, error) {
	rows, err := q.db.Query(ctx, getFormFields, formTemplateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FormField
	for rows.Next() {
		var i FormField
		if err := rows.Scan(
			&i.ID,
			&i.FormTemplateID,
			&i.FormSectionID,
			&i.FieldName,
			&i.FieldTypeID,
			&i.FieldOrder,
			&i.ConditionalLogic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormFieldsBySection = `-- name: GetFormFieldsBySection :many
SELECT id, form_template_id, form_section_id, field_name, field_type_id, field_order, conditional_logic, status, created_at, updated_at, deleted_at FROM form_fields
WHERE form_template_id = $1 AND form_section_id = $2 
AND status = 'active' AND deleted_at IS NULL
ORDER BY field_order
`

type GetFormFieldsBySectionParams struct {
	FormTemplateID pgtype.UUID `json:"form_template_id"`
	FormSectionID  pgtype.UUID `json:"form_section_id"`
}

func (q *Queries) GetFormFieldsBySection(ctx context.Context, arg GetFormFieldsBySectionParams) ([]FormField, error) {
	rows, err := q.db.Query(ctx, getFormFieldsBySection, arg.FormTemplateID, arg.FormSectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FormField
	for rows.Next() {
		var i FormField
		if err := rows.Scan(
			&i.ID,
			&i.FormTemplateID,
			&i.FormSectionID,
			&i.FieldName,
			&i.FieldTypeID,
			&i.FieldOrder,
			&i.ConditionalLogic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFormField = `-- name: UpdateFormField :one
UPDATE form_fields
SET 
    field_name = COALESCE($2, field_name),
    field_type_id = COALESCE($3, field_type_id),
    field_order = COALESCE($4, field_order),
    conditional_logic = COALESCE($5, conditional_logic),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, form_template_id, form_section_id, field_name, field_type_id, field_order, conditional_logic, status, created_at, updated_at, deleted_at
`

type UpdateFormFieldParams struct {
	ID               pgtype.UUID `json:"id"`
	FieldName        string      `json:"field_name"`
	FieldTypeID      pgtype.UUID `json:"field_type_id"`
	FieldOrder       int32       `json:"field_order"`
	ConditionalLogic []byte      `json:"conditional_logic"`
}

func (q *Queries) UpdateFormField(ctx context.Context, arg UpdateFormFieldParams) (FormField, error) {
	row := q.db.QueryRow(ctx, updateFormField,
		arg.ID,
		arg.FieldName,
		arg.FieldTypeID,
		arg.FieldOrder,
		arg.ConditionalLogic,
	)
	var i FormField
	err := row.Scan(
		&i.ID,
		&i.FormTemplateID,
		&i.FormSectionID,
		&i.FieldName,
		&i.FieldTypeID,
		&i.FieldOrder,
		&i.ConditionalLogic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
