// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: field_types.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFieldType = `-- name: CreateFieldType :one
INSERT INTO field_types (
    type_name, description, validation_schema
) VALUES ($1, $2, $3)
RETURNING id, type_name, description, validation_schema, status, created_at, updated_at, deleted_at
`

type CreateFieldTypeParams struct {
	TypeName         string      `json:"type_name"`
	Description      pgtype.Text `json:"description"`
	ValidationSchema []byte      `json:"validation_schema"`
}

func (q *Queries) CreateFieldType(ctx context.Context, arg CreateFieldTypeParams) (FieldType, error) {
	row := q.db.QueryRow(ctx, createFieldType, arg.TypeName, arg.Description, arg.ValidationSchema)
	var i FieldType
	err := row.Scan(
		&i.ID,
		&i.TypeName,
		&i.Description,
		&i.ValidationSchema,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteFieldType = `-- name: DeleteFieldType :exec
UPDATE field_types
SET 
    status = 'inactive',
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteFieldType(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFieldType, id)
	return err
}

const getFieldTypeByID = `-- name: GetFieldTypeByID :one
SELECT id, type_name, description, validation_schema, status, created_at, updated_at, deleted_at FROM field_types
WHERE id = $1 AND status = 'active' AND deleted_at IS NULL
`

func (q *Queries) GetFieldTypeByID(ctx context.Context, id pgtype.UUID) (FieldType, error) {
	row := q.db.QueryRow(ctx, getFieldTypeByID, id)
	var i FieldType
	err := row.Scan(
		&i.ID,
		&i.TypeName,
		&i.Description,
		&i.ValidationSchema,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFieldTypes = `-- name: GetFieldTypes :many
SELECT id, type_name, description, validation_schema, status, created_at, updated_at, deleted_at FROM field_types
WHERE status = 'active' AND deleted_at IS NULL
ORDER BY type_name
`

func (q *Queries) GetFieldTypes(ctx context.Context) ([]FieldType, error) {
	rows, err := q.db.Query(ctx, getFieldTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldType
	for rows.Next() {
		var i FieldType
		if err := rows.Scan(
			&i.ID,
			&i.TypeName,
			&i.Description,
			&i.ValidationSchema,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFieldType = `-- name: UpdateFieldType :one
UPDATE field_types
SET 
    type_name = COALESCE($2, type_name),
    description = COALESCE($3, description),
    validation_schema = COALESCE($4, validation_schema),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, type_name, description, validation_schema, status, created_at, updated_at, deleted_at
`

type UpdateFieldTypeParams struct {
	ID               pgtype.UUID `json:"id"`
	TypeName         string      `json:"type_name"`
	Description      pgtype.Text `json:"description"`
	ValidationSchema []byte      `json:"validation_schema"`
}

func (q *Queries) UpdateFieldType(ctx context.Context, arg UpdateFieldTypeParams) (FieldType, error) {
	row := q.db.QueryRow(ctx, updateFieldType,
		arg.ID,
		arg.TypeName,
		arg.Description,
		arg.ValidationSchema,
	)
	var i FieldType
	err := row.Scan(
		&i.ID,
		&i.TypeName,
		&i.Description,
		&i.ValidationSchema,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
