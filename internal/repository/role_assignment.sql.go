// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: role_assignment.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserPermission = `-- name: CheckUserPermission :one
SELECT COUNT(*) > 0 as hasPermission
FROM role_assignment ra
JOIN role_permissions rp ON ra.role_permissions_id = rp.id
JOIN permissions p ON rp.permission_id = p.id
WHERE ra.assignee_id = $1 
    AND p.resource = $2 
    AND p.action = $3
    AND ra.status = 'active'
    AND ra.deleted_at IS NULL
    AND rp.status = 'active'
    AND rp.deleted_at IS NULL
    AND (ra.expires_at IS NULL OR ra.expires_at > CURRENT_TIMESTAMP)
`

type CheckUserPermissionParams struct {
	AssigneeID pgtype.UUID `json:"assignee_id"`
	Resource   string      `json:"resource"`
	Action     string      `json:"action"`
}

func (q *Queries) CheckUserPermission(ctx context.Context, arg CheckUserPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserPermission, arg.AssigneeID, arg.Resource, arg.Action)
	var haspermission bool
	err := row.Scan(&haspermission)
	return haspermission, err
}

const createRoleAssignment = `-- name: CreateRoleAssignment :one
INSERT INTO role_assignment (
    role_permissions_id,
    assignee_id,
    business_unit_id,
    department_id,
    assigned_by,
    expires_at,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, role_permissions_id, assignee_id, business_unit_id, department_id, assigned_by, assigned_at, expires_at, status, updated_at, deleted_at
`

type CreateRoleAssignmentParams struct {
	RolePermissionsID pgtype.UUID        `json:"role_permissions_id"`
	AssigneeID        pgtype.UUID        `json:"assignee_id"`
	BusinessUnitID    pgtype.UUID        `json:"business_unit_id"`
	DepartmentID      pgtype.UUID        `json:"department_id"`
	AssignedBy        pgtype.UUID        `json:"assigned_by"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	Status            NullStatusEnum     `json:"status"`
}

func (q *Queries) CreateRoleAssignment(ctx context.Context, arg CreateRoleAssignmentParams) (RoleAssignment, error) {
	row := q.db.QueryRow(ctx, createRoleAssignment,
		arg.RolePermissionsID,
		arg.AssigneeID,
		arg.BusinessUnitID,
		arg.DepartmentID,
		arg.AssignedBy,
		arg.ExpiresAt,
		arg.Status,
	)
	var i RoleAssignment
	err := row.Scan(
		&i.ID,
		&i.RolePermissionsID,
		&i.AssigneeID,
		&i.BusinessUnitID,
		&i.DepartmentID,
		&i.AssignedBy,
		&i.AssignedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserRoleAssignments = `-- name: GetUserRoleAssignments :many
SELECT 
    ra.id,
    ra.role_permissions_id,
    ra.assignee_id,
    ra.business_unit_id,
    ra.department_id,
    ra.assigned_by,
    ra.assigned_at,
    ra.expires_at,
    ra.status,
    ra.updated_at,
    ra.deleted_at,
    r.name as role_name,
    p.name as permission_name,
    p.resource,
    p.action,
    s.name as scope_name,
    bu.name as business_unit_name,
    d.name as department_name
FROM role_assignment ra
JOIN role_permissions rp ON ra.role_permissions_id = rp.id
JOIN roles r ON rp.role_id = r.id
JOIN permissions p ON rp.permission_id = p.id
LEFT JOIN scopes s ON rp.scope_id = s.id
LEFT JOIN business_units bu ON ra.business_unit_id = bu.id
LEFT JOIN departments d ON ra.department_id = d.id
WHERE ra.assignee_id = $1 AND ra.deleted_at IS NULL
ORDER BY ra.assigned_at DESC
`

type GetUserRoleAssignmentsRow struct {
	ID                pgtype.UUID        `json:"id"`
	RolePermissionsID pgtype.UUID        `json:"role_permissions_id"`
	AssigneeID        pgtype.UUID        `json:"assignee_id"`
	BusinessUnitID    pgtype.UUID        `json:"business_unit_id"`
	DepartmentID      pgtype.UUID        `json:"department_id"`
	AssignedBy        pgtype.UUID        `json:"assigned_by"`
	AssignedAt        pgtype.Timestamptz `json:"assigned_at"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	Status            NullStatusEnum     `json:"status"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	RoleName          string             `json:"role_name"`
	PermissionName    string             `json:"permission_name"`
	Resource          string             `json:"resource"`
	Action            string             `json:"action"`
	ScopeName         pgtype.Text        `json:"scope_name"`
	BusinessUnitName  pgtype.Text        `json:"business_unit_name"`
	DepartmentName    pgtype.Text        `json:"department_name"`
}

func (q *Queries) GetUserRoleAssignments(ctx context.Context, assigneeID pgtype.UUID) ([]GetUserRoleAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, getUserRoleAssignments, assigneeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRoleAssignmentsRow
	for rows.Next() {
		var i GetUserRoleAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.RolePermissionsID,
			&i.AssigneeID,
			&i.BusinessUnitID,
			&i.DepartmentID,
			&i.AssignedBy,
			&i.AssignedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RoleName,
			&i.PermissionName,
			&i.Resource,
			&i.Action,
			&i.ScopeName,
			&i.BusinessUnitName,
			&i.DepartmentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
